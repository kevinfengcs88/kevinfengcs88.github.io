"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _dateFns = require("date-fns");

var _IndicatorButton = _interopRequireDefault(require("./IndicatorButton"));

var _icons = require("../icons");

var _tooltips = require("../tooltips");

var _utils = require("../../utils");

var _constants = require("../../constants");

var _enums = require("../../models/enums");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const InfoIndicatorButton = ({
  buttonIndex,
  orgId,
  siteId,
  erroredBuildId,
  isOnPrettyUrl,
  sitePrefix,
  buildId,
  createdAt,
  buildStatus
}) => {
  const initialButtonProps = {
    buttonIndex,
    testId: `info`,
    hoverable: true
  };
  const [buttonProps, setButtonProps] = (0, _react.useState)(initialButtonProps);
  const {
    setCookie
  } = (0, _utils.useCookie)();
  const {
    shouldShowFeedback
  } = (0, _utils.useFeedback)();
  const {
    track
  } = (0, _utils.useTrackEvent)();

  const trackClick = () => {
    track({
      eventType: `PREVIEW_INDICATOR_CLICK`,
      orgId,
      siteId,
      buildId,
      name: `info click`
    });
  };

  const trackHover = () => {
    track({
      eventType: `PREVIEW_INDICATOR_HOVER`,
      orgId,
      siteId,
      buildId,
      name: `info hover`
    });
  };

  const updateTootipVisibility = visible => {
    setButtonProps(btnProps => {
      return { ...btnProps,
        tooltip: { ...btnProps.tooltip,
          show: visible
        }
      };
    });
  };

  const closeInfoTooltip = () => {
    trackClick();
    setButtonProps(btnProps => {
      return { ...btnProps,
        tooltip: { ...btnProps.tooltip,
          show: false,
          overrideShow: false
        }
      };
    });
  };

  const closeFeedbackTooltip = () => {
    setButtonProps(btnProps => {
      return { ...btnProps,
        tooltip: { ...btnProps.tooltip,
          overrideShow: false,
          show: false
        },
        highlighted: false
      };
    }); // added settimeout until reveist to refactor code

    setTimeout(() => {
      const now = new Date();
      setCookie(_constants.FEEDBACK_COOKIE_NAME, now.toISOString());
      setCookie(_constants.INTERACTION_COOKIE_NAME, 0);
    }, 500);
  };

  (0, _react.useEffect)(() => {
    const buildStatusActions = {
      [_enums.BuildStatus.UPTODATE]: () => {
        if (shouldShowFeedback && buildStatus === _enums.BuildStatus.UPTODATE) {
          const url = _constants.FEEDBACK_URL;
          setButtonProps({ ...initialButtonProps,
            tooltip: {
              testId: initialButtonProps.testId,
              content: /*#__PURE__*/_react.default.createElement(_tooltips.FeedbackTooltipContent, {
                url: url,
                onOpened: () => {
                  closeFeedbackTooltip();
                }
              }),
              overrideShow: true,
              closable: true,
              onClose: closeFeedbackTooltip
            },
            active: true,
            highlighted: true
          });
        } else {
          setButtonProps(btnProps => {
            return { ...btnProps,
              tooltip: {
                testId: btnProps.testId,
                content: `Preview updated ${(0, _dateFns.formatDistance)(Date.now(), new Date(createdAt), {
                  includeSeconds: true
                })} ago`,
                overrideShow: false,
                show: false
              },
              active: true
            };
          });
        }
      },
      [_enums.BuildStatus.SUCCESS]: () => {
        setButtonProps(btnProps => {
          return { ...btnProps,
            tooltip: {
              testId: btnProps.testId,
              content: /*#__PURE__*/_react.default.createElement(_tooltips.BuildSuccessTooltipContent, {
                isOnPrettyUrl: isOnPrettyUrl,
                sitePrefix: sitePrefix,
                buildId: buildId,
                siteId: siteId,
                orgId: orgId
              }),
              closable: true,
              onClose: closeInfoTooltip
            },
            active: true,
            hoverable: true
          };
        });
      },
      [_enums.BuildStatus.ERROR]: () => {
        setButtonProps(btnProps => {
          return { ...btnProps,
            tooltip: {
              testId: btnProps.testId,
              content: /*#__PURE__*/_react.default.createElement(_tooltips.BuildErrorTooltipContent, {
                siteId: siteId,
                orgId: orgId,
                buildId: erroredBuildId
              }),
              overrideShow: true,
              closable: true,
              onClose: closeInfoTooltip
            },
            active: true,
            hoverable: true
          };
        });
      },
      [_enums.BuildStatus.BUILDING]: () => {
        setButtonProps(btnProps => {
          return { ...btnProps,
            tooltip: {
              testId: btnProps.testId,
              content: `Building a new preview`,
              overrideShow: true
            },
            active: false,
            hoverable: true,
            showSpinner: true
          };
        });
      }
    };
    const buildStatusAction = buildStatusActions[buildStatus];

    if (typeof buildStatusAction === `function`) {
      buildStatusAction();
    } else {
      setButtonProps({ ...buttonProps,
        active: true,
        hoverable: true
      });
    }
  }, [buildStatus, shouldShowFeedback]);
  return /*#__PURE__*/_react.default.createElement(_IndicatorButton.default, (0, _extends2.default)({}, buttonProps, {
    onClick: buttonProps !== null && buttonProps !== void 0 && buttonProps.active ? trackClick : undefined,
    onMouseEnter: buttonProps !== null && buttonProps !== void 0 && buttonProps.active ? trackHover : undefined,
    onTooltipToogle: updateTootipVisibility,
    iconSvg: shouldShowFeedback ? _icons.infoAlertIcon : _icons.infoIcon
  }));
};

var _default = InfoIndicatorButton;
exports.default = _default;